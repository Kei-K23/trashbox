//go:build darwin
// +build darwin

/*
Copyright Â© 2024 Kei-K23 <arkar.dev.kei@gmail.com>
*/

package trashbox

import (
	"bytes"
	"encoding/json"
	"fmt"
	"os"
	"os/exec"
	"path/filepath"
	"strings"
	"time"
)

type metadata struct {
	OriginalPath string    `json:"original_path"`
	DeletedAt    time.Time `json:"deleted_at"`
	Size         int64     `json:"size"`
}

var trashDir = filepath.Join(os.Getenv("HOME"), ".Trash")

const trashboxMetadataExt = ".trashbox.metadata.json"

// MoveToTrash moves the specified file or directory to the system's Trash directory.
// This function generates a metadata file in the Trash for potential recovery.
//
// Parameters:
//
//	path (string): The path of the file or directory to be moved to Trash.
//
// Returns:
//
//	error: Returns an error if the file cannot be moved to Trash or if there are issues
//	       in creating the metadata file. Returns nil if successful.
//
// Example usage:
//
//	err := MoveToTrash("/path/to/file.txt")
//	if err != nil {
//	    log.Fatalf("Failed to move file to Trash: %v", err)
//	}
//
// Notes:
//   - On success, a metadata file is created in the Trash directory that stores the
//     original location of the deleted file. This enables the file to be put back
//     using the PutBackFromTrash function.
//   - The function is currently tailored for macOS systems.
func MoveToTrash(path string) error {
	// Get the absolute file path of delete file
	absPath, err := filepath.Abs(path)
	if err != nil {
		return err
	}

	info, err := os.Stat(absPath)
	if err != nil {
		return err
	}

	// Get the trash file path to move to .Trash directory
	trashPath := filepath.Join(trashDir, filepath.Base(path))
	// Move the file to .Trash directory
	err = os.Rename(absPath, trashPath)
	if err != nil {
		return err
	}

	// Create metadata file for recovery the deleted file
	metadata := metadata{OriginalPath: absPath, DeletedAt: time.Now(), Size: info.Size()}
	metadataPath := trashPath + trashboxMetadataExt

	// Create metadata file in Trash bin
	metadataFile, err := os.Create(metadataPath)
	if err != nil {
		return err
	}
	defer metadataFile.Close()

	encoder := json.NewEncoder(metadataFile)
	err = encoder.Encode(metadata)
	if err != nil {
		return err
	}

	// Process is success and return nill
	return nil
}

// PutBackFromTrash restores a previously deleted file from the Trash to its original location.
// The original location is determined from the metadata generated when the file was moved to Trash.
//
// Parameters:
//
//	path (string): The name of the file or directory to be restored from Trash.
//
// Returns:
//
//	error: Returns an error if the file cannot be restored or if there are issues
//	       with reading the metadata file. Returns nil if successful.
//
// Example usage:
//
//	err := PutBackFromTrash("file.txt")
//	if err != nil {
//	    log.Fatalf("Failed to put back file from Trash: %v", err)
//	}
//
// Notes:
//   - The function depends on a metadata file (generated by MoveToTrash) being present
//     in the Trash directory, which contains the original path.
//   - On success, the metadata file is removed from the Trash.
func PutBackFromTrash(path string) error {
	// Get the Trash box path and metadata path
	trashPath := filepath.Join(trashDir, path)
	metadataPath := trashPath + trashboxMetadataExt

	// Open metadata file to get original file path
	metadataFile, err := os.Open(metadataPath)
	if err != nil {
		return err
	}
	defer metadataFile.Close()

	var metadata metadata
	decoder := json.NewDecoder(metadataFile)
	err = decoder.Decode(&metadata)
	if err != nil {
		return err
	}

	// Put back file to original path
	err = os.Rename(trashPath, metadata.OriginalPath)
	if err != nil {
		return err
	}

	// Remove the metadata file
	err = os.Remove(metadataPath)
	if err != nil {
		return err
	}

	// Process is success and return nill
	return nil
}

// ListTrash shows a list of metadata that related to moved files by MoveToTrash.
//
// Notes:
//   - ListTrash only shows the metadata of file that was moved by MoveToTrash.
//
// Returns:
//
//	[]metadata: Returns a slice of metadata struct
//
//	error: Returns an error when reading and listing metadata file inside Trash.
//
// Example usage:
//
//	files, err := ListTrash()
//	if err != nil {
//	    log.Fatalf("Failed to list metadata of files: %v", err)
//	}
//
// Notes:
//   - The function depends on a metadata file (generated by MoveToTrash) being present
//     in the Trash directory, which contains the original path.
func ListTrash() ([]metadata, error) {
	var files []metadata

	parts, err := listTrashUsingAppleScript()
	if err != nil {
		return nil, err
	}

	if len(parts) == 0 {
		return nil, fmt.Errorf("empty trash bin")
	}

	entries := strings.Split(parts[0], ",")

	for _, entry := range entries {
		if strings.HasSuffix(entry, ".metadata.json") {
			filePath := filepath.Join(trashDir, strings.TrimSpace(entry))
			file, err := os.Open(filePath)
			if err != nil {
				return nil, err
			}
			defer file.Close()

			var metadata metadata
			decoder := json.NewDecoder(file)
			if err = decoder.Decode(&metadata); err != nil {
				return nil, err
			}
			files = append(files, metadata)
		}
	}

	return files, nil
}

func listTrashUsingAppleScript() ([]string, error) {
	script := `tell application "Finder" to get the name of every file of trash`
	cmd := exec.Command("osascript", "-e", script)

	var out bytes.Buffer
	cmd.Stdout = &out
	err := cmd.Run()
	if err != nil {
		return nil, err
	}

	// Split the output by new lines and convert each entry to a string
	var files []string
	for _, b := range bytes.Split(out.Bytes(), []byte{'\n'}) {
		if len(b) > 0 { // Check to avoid adding empty entries
			files = append(files, string(b))
		}
	}

	return files, nil
}
